# coding: utf-8
"""Waylay Query: timeseries queries (v1 protocol) api tests.

This code was generated from the OpenAPI documentation of 'Waylay Query: timeseries queries (v1 protocol)'

Generated by OpenAPI Generator (https://openapi-generator.tech)

Do not edit the class manually.
"""

import json
import re
from importlib.util import find_spec
from typing import Union
from urllib.parse import quote

import pytest
from pytest_httpx import HTTPXMock
from typeguard import check_type
from waylay.sdk import ApiClient, WaylayClient
from waylay.sdk.api._models import Model
from waylay.services.queries.api import ExecuteApi
from waylay.services.queries.service import QueriesService

from ..types.aggregation_method_stub import AggregationMethodStub
from ..types.from_override_stub import FromOverrideStub
from ..types.grouping_interval_override_stub import GroupingIntervalOverrideStub
from ..types.interpolation_stub import InterpolationStub
from ..types.query_input_stub import QueryInputStub
from ..types.query_result_stub import QueryResultStub
from ..types.render1_stub import Render1Stub
from ..types.window_override_stub import WindowOverrideStub

MODELS_AVAILABLE = (
    True if find_spec("waylay.services.queries.models") is not None else False
)

if MODELS_AVAILABLE:
    from waylay.services.queries.models import QueryResult
    from waylay.services.queries.queries.execute_api import (
        ExecuteByNameQuery,
        ExecuteQuery,
    )


# some mappings that are needed for some <example> interpolations
null, true, false = None, True, False


@pytest.fixture
def execute_api(waylay_api_client: ApiClient) -> ExecuteApi:
    return ExecuteApi(waylay_api_client)


def test_registered(waylay_client: WaylayClient):
    """Test that ExecuteApi api is registered in the sdk client."""
    assert isinstance(waylay_client.queries.execute, ExecuteApi)


def _execute_by_name_set_mock_response(
    httpx_mock: HTTPXMock, gateway_url: str, query_name: str
):
    mock_response = QueryResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "GET",
        "url": re.compile(f"^{gateway_url}/queries/v1/data/{query_name}(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute_by_name(
    service: QueriesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_by_name
    Execute Named Query
    """
    # set path params
    query_name = "query_name_example"

    kwargs = {
        # optionally use ExecuteByNameQuery to validate and reuse parameters
        "query": ExecuteByNameQuery(
            resource="13efb488-75ac-4dac-828a-d49c5c2ebbfc",
            metric="temperature",
            aggregation=AggregationMethodStub.create_json(),
            interpolation=InterpolationStub.create_json(),
            freq=GroupingIntervalOverrideStub.create_json(),
            var_from=FromOverrideStub.create_json(),
            until=FromOverrideStub.create_json(),
            window=WindowOverrideStub.create_json(),
            periods=56,
            render=Render1Stub.create_json(),
        ),
    }
    _execute_by_name_set_mock_response(httpx_mock, gateway_url, quote(str(query_name)))
    resp = await service.execute.execute_by_name(query_name, **kwargs)
    check_type(resp, Union[QueryResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_by_name_without_types(
    service: QueriesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute_by_name with models not installed
    Execute Named Query
    """
    # set path params
    query_name = "query_name_example"

    kwargs = {
        "query": {
            "resource": "13efb488-75ac-4dac-828a-d49c5c2ebbfc",
            "metric": "temperature",
            "aggregation": AggregationMethodStub.create_json(),
            "interpolation": InterpolationStub.create_json(),
            "freq": GroupingIntervalOverrideStub.create_json(),
            "from": FromOverrideStub.create_json(),
            "until": FromOverrideStub.create_json(),
            "window": WindowOverrideStub.create_json(),
            "periods": 56,
            "render": Render1Stub.create_json(),
        },
    }
    _execute_by_name_set_mock_response(httpx_mock, gateway_url, quote(str(query_name)))
    resp = await service.execute.execute_by_name(query_name, **kwargs)
    check_type(resp, Model)


def _execute_set_mock_response(httpx_mock: HTTPXMock, gateway_url: str):
    mock_response = QueryResultStub.create_json()
    httpx_mock_kwargs = {
        "method": "POST",
        "url": re.compile(f"^{gateway_url}/queries/v1/data(\\?.*)?"),
        "content": json.dumps(mock_response, default=str),
        "status_code": 200,
    }
    httpx_mock.add_response(**httpx_mock_kwargs)


@pytest.mark.asyncio
@pytest.mark.skipif(not MODELS_AVAILABLE, reason="Types not installed.")
async def test_execute(
    service: QueriesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute
    Execute Query
    """
    # set path params
    kwargs = {
        # optionally use ExecuteQuery to validate and reuse parameters
        "query": ExecuteQuery(
            resource="13efb488-75ac-4dac-828a-d49c5c2ebbfc",
            metric="temperature",
            aggregation=AggregationMethodStub.create_json(),
            interpolation=InterpolationStub.create_json(),
            freq=GroupingIntervalOverrideStub.create_json(),
            var_from=FromOverrideStub.create_json(),
            until=FromOverrideStub.create_json(),
            window=WindowOverrideStub.create_json(),
            periods=56,
            render=Render1Stub.create_json(),
        ),
        "json": QueryInputStub.create_instance(),
    }
    _execute_set_mock_response(httpx_mock, gateway_url)
    resp = await service.execute.execute(**kwargs)
    check_type(resp, Union[QueryResult,])


@pytest.mark.asyncio
@pytest.mark.skipif(MODELS_AVAILABLE, reason="Types installed.")
async def test_execute_without_types(
    service: QueriesService, gateway_url: str, httpx_mock: HTTPXMock
):
    """Test case for execute with models not installed
    Execute Query
    """
    # set path params
    kwargs = {
        "query": {
            "resource": "13efb488-75ac-4dac-828a-d49c5c2ebbfc",
            "metric": "temperature",
            "aggregation": AggregationMethodStub.create_json(),
            "interpolation": InterpolationStub.create_json(),
            "freq": GroupingIntervalOverrideStub.create_json(),
            "from": FromOverrideStub.create_json(),
            "until": FromOverrideStub.create_json(),
            "window": WindowOverrideStub.create_json(),
            "periods": 56,
            "render": Render1Stub.create_json(),
        },
        "json": QueryInputStub.create_json(),
    }
    _execute_set_mock_response(httpx_mock, gateway_url)
    resp = await service.execute.execute(**kwargs)
    check_type(resp, Model)
